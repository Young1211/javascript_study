<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Method Chaining</title>
  </head>
  <body>
    <!-- 함수를 호출할 때 객체를 반환 -->

    <script>
      //과일의 데이터를 가지고 있는 fruit
      const fruit = ["사과", "딸기", "포도", "복숭아", "바나나"];

      function fun1(fruit) {
        let result = fruit.filter((item) => item.length >= 3);
        return result;
      }

      fun1(fruit).map((it) => {
        console.log(it);
      });
      //복숭아, 바나나 출력
      //fun1의 반환 값 -> result(배열)을 통해
      //map이라는 또 다른 함수 호출

      //예제2
      //정수 n을 매개변수로 입력받아, n의 각 자릿수를 큰 것부터 작은 순으로 정렬
      //정수 -> String 화 -> parseInt
      //큰 것부터 작은 순으로 정렬

      function solution(n) {
        let answer = parseInt(String(n).split("").reverse().join(""));
        console.log(typeof answer); //number
        return answer;
      }

      let num = 118372;
      console.log(solution(num));
    </script>
  </body>
</html>

<!-- 

  메서드 체이닝
  -사슬에 이어진 고리처럼, 함수를 호출할 때 객체를 반환하면, 
  객체 안에 있는 메서드를 줄줄이 이어서 호출
 -메서드 체이닝을 지나치게 사용하면 가독성이 떨어짐
 -메서드가 객체를 리턴해야지, 메서드 체이닝이 가능


 -프라미스 체이닝
 -promise.then을 이용하면 프라미스가 반환됨
 -반환된 프라미스엔 당연히 .then을 호출할 수 있음 
- 이것도 같이 공부
 




 -->
